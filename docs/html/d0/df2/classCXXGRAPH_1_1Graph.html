<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CXXGraph: CXXGRAPH::Graph&lt; T &gt; Class Template Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CXXGraph
   &#160;<span id="projectnumber">0.4.0</span>
   </div>
   <div id="projectbrief">CXXGraph is a header only, that manages the Graphs and it&#39;s algorithm in C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>CXXGRAPH</b></li><li class="navelem"><a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html">Graph</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="../../de/d77/classCXXGRAPH_1_1Graph-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">CXXGRAPH::Graph&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class that implement the <a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html" title="Class that implement the Graph. ( This class is not Thread Safe )">Graph</a>. ( This class is not Thread Safe )  
 <a href="../../d0/df2/classCXXGRAPH_1_1Graph.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../d9/d69/Graph_8hpp_source.html">Graph.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for CXXGRAPH::Graph&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="../../dc/d80/classCXXGRAPH_1_1Graph__inherit__graph.png" border="0" usemap="#aCXXGRAPH_1_1Graph_3_01T_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="aCXXGRAPH_1_1Graph_3_01T_01_4_inherit__map" id="aCXXGRAPH_1_1Graph_3_01T_01_4_inherit__map">
<area shape="rect" title="Class that implement the Graph. ( This class is not Thread Safe )" alt="" coords="21,5,187,32"/>
<area shape="rect" href="../../de/d59/classCXXGRAPH_1_1PARTITIONING_1_1Partition.html" title=" " alt="" coords="5,80,203,121"/>
</map>
<center><span class="legend">[<a href="../../graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7b66a2077835e57dbbe0429ca3cbde05"><td class="memItemLeft" align="right" valign="top"><a id="a7b66a2077835e57dbbe0429ca3cbde05"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Graph</b> (const T_EdgeSet&lt; T &gt; &amp;edgeSet)</td></tr>
<tr class="separator:a7b66a2077835e57dbbe0429ca3cbde05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8412ba5fbb3bd12ce9c872bd9bbd9824"><td class="memItemLeft" align="right" valign="top">virtual const T_EdgeSet&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html#a8412ba5fbb3bd12ce9c872bd9bbd9824">getEdgeSet</a> () const</td></tr>
<tr class="memdesc:a8412ba5fbb3bd12ce9c872bd9bbd9824"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that return the <a class="el" href="../../d7/d2a/classCXXGRAPH_1_1Edge.html">Edge</a> set of the <a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html" title="Class that implement the Graph. ( This class is not Thread Safe )">Graph</a> Note: No Thread Safe.  <a href="../../d0/df2/classCXXGRAPH_1_1Graph.html#a8412ba5fbb3bd12ce9c872bd9bbd9824">More...</a><br /></td></tr>
<tr class="separator:a8412ba5fbb3bd12ce9c872bd9bbd9824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f4b22c1c3e93bd51600141d9517e36a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html#a7f4b22c1c3e93bd51600141d9517e36a">setEdgeSet</a> (T_EdgeSet&lt; T &gt; &amp;edgeSet)</td></tr>
<tr class="memdesc:a7f4b22c1c3e93bd51600141d9517e36a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function set the <a class="el" href="../../d7/d2a/classCXXGRAPH_1_1Edge.html">Edge</a> Set of the <a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html" title="Class that implement the Graph. ( This class is not Thread Safe )">Graph</a> Note: No Thread Safe.  <a href="../../d0/df2/classCXXGRAPH_1_1Graph.html#a7f4b22c1c3e93bd51600141d9517e36a">More...</a><br /></td></tr>
<tr class="separator:a7f4b22c1c3e93bd51600141d9517e36a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95fc676b51609323126e1d6f2366c4bb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html#a95fc676b51609323126e1d6f2366c4bb">addEdge</a> (const <a class="el" href="../../d7/d2a/classCXXGRAPH_1_1Edge.html">Edge</a>&lt; T &gt; *edge)</td></tr>
<tr class="memdesc:a95fc676b51609323126e1d6f2366c4bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function add an <a class="el" href="../../d7/d2a/classCXXGRAPH_1_1Edge.html">Edge</a> to the <a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html" title="Class that implement the Graph. ( This class is not Thread Safe )">Graph</a> <a class="el" href="../../d7/d2a/classCXXGRAPH_1_1Edge.html">Edge</a> Set Note: No Thread Safe.  <a href="../../d0/df2/classCXXGRAPH_1_1Graph.html#a95fc676b51609323126e1d6f2366c4bb">More...</a><br /></td></tr>
<tr class="separator:a95fc676b51609323126e1d6f2366c4bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1b14104add48bad5524e31b47411d36"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html#ac1b14104add48bad5524e31b47411d36">removeEdge</a> (unsigned long long edgeId)</td></tr>
<tr class="memdesc:ac1b14104add48bad5524e31b47411d36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function remove an <a class="el" href="../../d7/d2a/classCXXGRAPH_1_1Edge.html">Edge</a> from the <a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html" title="Class that implement the Graph. ( This class is not Thread Safe )">Graph</a> <a class="el" href="../../d7/d2a/classCXXGRAPH_1_1Edge.html">Edge</a> Set Note: No Thread Safe.  <a href="../../d0/df2/classCXXGRAPH_1_1Graph.html#ac1b14104add48bad5524e31b47411d36">More...</a><br /></td></tr>
<tr class="separator:ac1b14104add48bad5524e31b47411d36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0544d74b956980e05e2a57a5dc2d2d6"><td class="memItemLeft" align="right" valign="top">virtual const std::set&lt; const <a class="el" href="../../d3/dd2/classCXXGRAPH_1_1Node.html">Node</a>&lt; T &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html#af0544d74b956980e05e2a57a5dc2d2d6">getNodeSet</a> () const</td></tr>
<tr class="memdesc:af0544d74b956980e05e2a57a5dc2d2d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that return the <a class="el" href="../../d3/dd2/classCXXGRAPH_1_1Node.html">Node</a> Set of the <a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html" title="Class that implement the Graph. ( This class is not Thread Safe )">Graph</a> Note: No Thread Safe.  <a href="../../d0/df2/classCXXGRAPH_1_1Graph.html#af0544d74b956980e05e2a57a5dc2d2d6">More...</a><br /></td></tr>
<tr class="separator:af0544d74b956980e05e2a57a5dc2d2d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ebab9011fe6155743eaa989c2bf7860"><td class="memItemLeft" align="right" valign="top">virtual const std::optional&lt; const <a class="el" href="../../d7/d2a/classCXXGRAPH_1_1Edge.html">Edge</a>&lt; T &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html#a5ebab9011fe6155743eaa989c2bf7860">getEdge</a> (unsigned long long edgeId) const</td></tr>
<tr class="memdesc:a5ebab9011fe6155743eaa989c2bf7860"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that return an <a class="el" href="../../d7/d2a/classCXXGRAPH_1_1Edge.html">Edge</a> with specific ID if Exist in the <a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html" title="Class that implement the Graph. ( This class is not Thread Safe )">Graph</a> Note: No Thread Safe.  <a href="../../d0/df2/classCXXGRAPH_1_1Graph.html#a5ebab9011fe6155743eaa989c2bf7860">More...</a><br /></td></tr>
<tr class="separator:a5ebab9011fe6155743eaa989c2bf7860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad000477b7a25ea7bfd1edf589133b042"><td class="memItemLeft" align="right" valign="top"><a id="ad000477b7a25ea7bfd1edf589133b042"></a>
virtual const AdjacencyMatrix&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html#ad000477b7a25ea7bfd1edf589133b042">getAdjMatrix</a> () const</td></tr>
<tr class="memdesc:ad000477b7a25ea7bfd1edf589133b042"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function generate a list of adjacency matrix with every element of the matrix contain the node where is directed the link and the <a class="el" href="../../d7/d2a/classCXXGRAPH_1_1Edge.html">Edge</a> corrispondent to the link Note: No Thread Safe. <br /></td></tr>
<tr class="separator:ad000477b7a25ea7bfd1edf589133b042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cc15d4668136f6be44bf18a2e28cc6b"><td class="memItemLeft" align="right" valign="top">virtual unsigned long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html#a0cc15d4668136f6be44bf18a2e28cc6b">setFind</a> (std::unordered_map&lt; unsigned long long, <a class="el" href="../../dc/daa/structCXXGRAPH_1_1Subset__struct.html">Subset</a> &gt; *, const unsigned long long elem) const</td></tr>
<tr class="memdesc:a0cc15d4668136f6be44bf18a2e28cc6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function finds the subset of given a nodeId Subset is stored in a map where keys are the hash-id of the node &amp; values is the subset.  <a href="../../d0/df2/classCXXGRAPH_1_1Graph.html#a0cc15d4668136f6be44bf18a2e28cc6b">More...</a><br /></td></tr>
<tr class="separator:a0cc15d4668136f6be44bf18a2e28cc6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60a3f55bd4b195d7225b77b3ae8c9065"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html#a60a3f55bd4b195d7225b77b3ae8c9065">setUnion</a> (std::unordered_map&lt; unsigned long long, <a class="el" href="../../dc/daa/structCXXGRAPH_1_1Subset__struct.html">Subset</a> &gt; *, const unsigned long long set1, const unsigned long long elem2) const</td></tr>
<tr class="memdesc:a60a3f55bd4b195d7225b77b3ae8c9065"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function modifies the original subset array such that it the union of two sets a and b.  <a href="../../d0/df2/classCXXGRAPH_1_1Graph.html#a60a3f55bd4b195d7225b77b3ae8c9065">More...</a><br /></td></tr>
<tr class="separator:a60a3f55bd4b195d7225b77b3ae8c9065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31b482ce494f93dcd7125b3aa4eb8f78"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="../../d3/dd2/classCXXGRAPH_1_1Node.html">Node</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html#a31b482ce494f93dcd7125b3aa4eb8f78">eulerianPath</a> () const</td></tr>
<tr class="memdesc:a31b482ce494f93dcd7125b3aa4eb8f78"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function finds the eulerian path of a directed graph using hierholzers algorithm.  <a href="../../d0/df2/classCXXGRAPH_1_1Graph.html#a31b482ce494f93dcd7125b3aa4eb8f78">More...</a><br /></td></tr>
<tr class="separator:a31b482ce494f93dcd7125b3aa4eb8f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d655cd624cedf47ee366d8c0ab31921"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="../../dd/d6c/structCXXGRAPH_1_1DijkstraResult__struct.html">DijkstraResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html#a8d655cd624cedf47ee366d8c0ab31921">dijkstra</a> (const <a class="el" href="../../d3/dd2/classCXXGRAPH_1_1Node.html">Node</a>&lt; T &gt; &amp;source, const <a class="el" href="../../d3/dd2/classCXXGRAPH_1_1Node.html">Node</a>&lt; T &gt; &amp;target) const</td></tr>
<tr class="memdesc:a8d655cd624cedf47ee366d8c0ab31921"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function runs the dijkstra algorithm for some source node and target node in the graph and returns the shortest distance of target from the source. Note: No Thread Safe.  <a href="../../d0/df2/classCXXGRAPH_1_1Graph.html#a8d655cd624cedf47ee366d8c0ab31921">More...</a><br /></td></tr>
<tr class="separator:a8d655cd624cedf47ee366d8c0ab31921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae88da3d693fb461b53435d94e12e166c"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="../../d4/df1/structCXXGRAPH_1_1BellmanFordResult__struct.html">BellmanFordResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html#ae88da3d693fb461b53435d94e12e166c">bellmanford</a> (const <a class="el" href="../../d3/dd2/classCXXGRAPH_1_1Node.html">Node</a>&lt; T &gt; &amp;source, const <a class="el" href="../../d3/dd2/classCXXGRAPH_1_1Node.html">Node</a>&lt; T &gt; &amp;target) const</td></tr>
<tr class="memdesc:ae88da3d693fb461b53435d94e12e166c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function runs the bellman-ford algorithm for some source node and target node in the graph and returns the shortest distance of target from the source. It can also detect if a negative cycle exists in the graph. Note: No Thread Safe.  <a href="../../d0/df2/classCXXGRAPH_1_1Graph.html#ae88da3d693fb461b53435d94e12e166c">More...</a><br /></td></tr>
<tr class="separator:ae88da3d693fb461b53435d94e12e166c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00b6780a5167547fe05db00e01011223"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="../../dc/da9/structCXXGRAPH_1_1FWResult__struct.html">FWResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html#a00b6780a5167547fe05db00e01011223">floydWarshall</a> () const</td></tr>
<tr class="memdesc:a00b6780a5167547fe05db00e01011223"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function runs the floyd-warshall algorithm and returns the shortest distance of all pair of nodes. It can also detect if a negative cycle exists in the graph. Note: No Thread Safe.  <a href="../../d0/df2/classCXXGRAPH_1_1Graph.html#a00b6780a5167547fe05db00e01011223">More...</a><br /></td></tr>
<tr class="separator:a00b6780a5167547fe05db00e01011223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dd966cbf26d661a017e36d568fa3223"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="../../d4/d63/structCXXGRAPH_1_1MstResult__struct.html">MstResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html#a1dd966cbf26d661a017e36d568fa3223">prim</a> () const</td></tr>
<tr class="memdesc:a1dd966cbf26d661a017e36d568fa3223"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function runs the prim algorithm and returns the minimum spanning tree if the graph is undirected. Note: No Thread Safe.  <a href="../../d0/df2/classCXXGRAPH_1_1Graph.html#a1dd966cbf26d661a017e36d568fa3223">More...</a><br /></td></tr>
<tr class="separator:a1dd966cbf26d661a017e36d568fa3223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ff4c2379cae5b2426788e4bbcd174bc"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="../../d4/d63/structCXXGRAPH_1_1MstResult__struct.html">MstResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html#a8ff4c2379cae5b2426788e4bbcd174bc">boruvka</a> () const</td></tr>
<tr class="memdesc:a8ff4c2379cae5b2426788e4bbcd174bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function runs the boruvka algorithm and returns the minimum spanning tree &amp; cost if the graph is undirected. Note: No Thread Safe.  <a href="../../d0/df2/classCXXGRAPH_1_1Graph.html#a8ff4c2379cae5b2426788e4bbcd174bc">More...</a><br /></td></tr>
<tr class="separator:a8ff4c2379cae5b2426788e4bbcd174bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd02bf70592b8f706d441e82bbe6ddc9"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="../../d4/d63/structCXXGRAPH_1_1MstResult__struct.html">MstResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html#acd02bf70592b8f706d441e82bbe6ddc9">kruskal</a> () const</td></tr>
<tr class="memdesc:acd02bf70592b8f706d441e82bbe6ddc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function runs the kruskal algorithm and returns the minimum spanning tree if the graph is undirected. Note: No Thread Safe.  <a href="../../d0/df2/classCXXGRAPH_1_1Graph.html#acd02bf70592b8f706d441e82bbe6ddc9">More...</a><br /></td></tr>
<tr class="separator:acd02bf70592b8f706d441e82bbe6ddc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae94a68dc57331c26070c3aec035264ef"><td class="memItemLeft" align="right" valign="top">virtual const std::vector&lt; <a class="el" href="../../d3/dd2/classCXXGRAPH_1_1Node.html">Node</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html#ae94a68dc57331c26070c3aec035264ef">breadth_first_search</a> (const <a class="el" href="../../d3/dd2/classCXXGRAPH_1_1Node.html">Node</a>&lt; T &gt; &amp;start) const</td></tr>
<tr class="memdesc:ae94a68dc57331c26070c3aec035264ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function performs the breadth first search algorithm over the graph Note: No Thread Safe.  <a href="../../d0/df2/classCXXGRAPH_1_1Graph.html#ae94a68dc57331c26070c3aec035264ef">More...</a><br /></td></tr>
<tr class="separator:ae94a68dc57331c26070c3aec035264ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05d230bd6185b99b624227c4c82b7811"><td class="memItemLeft" align="right" valign="top">virtual const std::vector&lt; <a class="el" href="../../d3/dd2/classCXXGRAPH_1_1Node.html">Node</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html#a05d230bd6185b99b624227c4c82b7811">depth_first_search</a> (const <a class="el" href="../../d3/dd2/classCXXGRAPH_1_1Node.html">Node</a>&lt; T &gt; &amp;start) const</td></tr>
<tr class="memdesc:a05d230bd6185b99b624227c4c82b7811"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function performs the depth first search algorithm over the graph Note: No Thread Safe.  <a href="../../d0/df2/classCXXGRAPH_1_1Graph.html#a05d230bd6185b99b624227c4c82b7811">More...</a><br /></td></tr>
<tr class="separator:a05d230bd6185b99b624227c4c82b7811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a818601c0df0e5abfbaf4da5918afa"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html#a91a818601c0df0e5abfbaf4da5918afa">isCyclicDirectedGraphDFS</a> () const</td></tr>
<tr class="memdesc:a91a818601c0df0e5abfbaf4da5918afa"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function uses DFS to check for cycle in the graph. Pay Attention, this function work only with directed <a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html" title="Class that implement the Graph. ( This class is not Thread Safe )">Graph</a> Note: No Thread Safe.  <a href="../../d0/df2/classCXXGRAPH_1_1Graph.html#a91a818601c0df0e5abfbaf4da5918afa">More...</a><br /></td></tr>
<tr class="separator:a91a818601c0df0e5abfbaf4da5918afa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f76bb7230c1654dd6b1ec24d0291875"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html#a4f76bb7230c1654dd6b1ec24d0291875">isCyclicDirectedGraphBFS</a> () const</td></tr>
<tr class="memdesc:a4f76bb7230c1654dd6b1ec24d0291875"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function uses BFS to check for cycle in the graph. Pay Attention, this function work only with directed <a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html" title="Class that implement the Graph. ( This class is not Thread Safe )">Graph</a> Note: No Thread Safe.  <a href="../../d0/df2/classCXXGRAPH_1_1Graph.html#a4f76bb7230c1654dd6b1ec24d0291875">More...</a><br /></td></tr>
<tr class="separator:a4f76bb7230c1654dd6b1ec24d0291875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54c736ce873d01a0ae290e8a2b448ca2"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html#a54c736ce873d01a0ae290e8a2b448ca2">containsCycle</a> (const T_EdgeSet&lt; T &gt; *) const</td></tr>
<tr class="memdesc:a54c736ce873d01a0ae290e8a2b448ca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks if the given set of edges forms a cycle or not using union-find method.  <a href="../../d0/df2/classCXXGRAPH_1_1Graph.html#a54c736ce873d01a0ae290e8a2b448ca2">More...</a><br /></td></tr>
<tr class="separator:a54c736ce873d01a0ae290e8a2b448ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa6c90c1c0e48c74fd486ef87b9626dd"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html#afa6c90c1c0e48c74fd486ef87b9626dd">containsCycle</a> (const T_EdgeSet&lt; T &gt; *edgeSet, std::unordered_map&lt; unsigned long long, <a class="el" href="../../dc/daa/structCXXGRAPH_1_1Subset__struct.html">Subset</a> &gt; *) const</td></tr>
<tr class="memdesc:afa6c90c1c0e48c74fd486ef87b9626dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks if the given Subset forms a cycle or not using union-find method.  <a href="../../d0/df2/classCXXGRAPH_1_1Graph.html#afa6c90c1c0e48c74fd486ef87b9626dd">More...</a><br /></td></tr>
<tr class="separator:afa6c90c1c0e48c74fd486ef87b9626dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c7ddb5c91f3ab7456c8203a740f52c9"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html#a5c7ddb5c91f3ab7456c8203a740f52c9">isDirectedGraph</a> () const</td></tr>
<tr class="memdesc:a5c7ddb5c91f3ab7456c8203a740f52c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks if a graph is directed Note: No Thread Safe.  <a href="../../d0/df2/classCXXGRAPH_1_1Graph.html#a5c7ddb5c91f3ab7456c8203a740f52c9">More...</a><br /></td></tr>
<tr class="separator:a5c7ddb5c91f3ab7456c8203a740f52c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13abdb1d53937f7349cd72f527125edf"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html#a13abdb1d53937f7349cd72f527125edf">isUndirectedGraph</a> () const</td></tr>
<tr class="memdesc:a13abdb1d53937f7349cd72f527125edf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks if a graph is undirected Note: No Thread Safe.  <a href="../../d0/df2/classCXXGRAPH_1_1Graph.html#a13abdb1d53937f7349cd72f527125edf">More...</a><br /></td></tr>
<tr class="separator:a13abdb1d53937f7349cd72f527125edf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c7fc1183438f6f699179a4b02d39b68"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html#a1c7fc1183438f6f699179a4b02d39b68">isConnectedGraph</a> () const</td></tr>
<tr class="memdesc:a1c7fc1183438f6f699179a4b02d39b68"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks if the graph is connected or not Applicable for Undirected <a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html" title="Class that implement the Graph. ( This class is not Thread Safe )">Graph</a>, for Directed <a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html" title="Class that implement the Graph. ( This class is not Thread Safe )">Graph</a> use the <a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html#a2dd3a83617afbd6a27d9f835f0ac7996" title="This function checks if the graph is strongly connected or not Applicable for Directed Graph,...">isStronglyConnectedGraph()</a> function.  <a href="../../d0/df2/classCXXGRAPH_1_1Graph.html#a1c7fc1183438f6f699179a4b02d39b68">More...</a><br /></td></tr>
<tr class="separator:a1c7fc1183438f6f699179a4b02d39b68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dd3a83617afbd6a27d9f835f0ac7996"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html#a2dd3a83617afbd6a27d9f835f0ac7996">isStronglyConnectedGraph</a> () const</td></tr>
<tr class="memdesc:a2dd3a83617afbd6a27d9f835f0ac7996"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks if the graph is strongly connected or not Applicable for Directed <a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html" title="Class that implement the Graph. ( This class is not Thread Safe )">Graph</a>, for Undirected <a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html" title="Class that implement the Graph. ( This class is not Thread Safe )">Graph</a> use the <a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html#a1c7fc1183438f6f699179a4b02d39b68" title="This function checks if the graph is connected or not Applicable for Undirected Graph,...">isConnectedGraph()</a> function.  <a href="../../d0/df2/classCXXGRAPH_1_1Graph.html#a2dd3a83617afbd6a27d9f835f0ac7996">More...</a><br /></td></tr>
<tr class="separator:a2dd3a83617afbd6a27d9f835f0ac7996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5905a6243d88a7c347c003b9c8789801"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::vector&lt; <a class="el" href="../../d3/dd2/classCXXGRAPH_1_1Node.html">Node</a>&lt; T &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html#a5905a6243d88a7c347c003b9c8789801">kosaraju</a> () const</td></tr>
<tr class="memdesc:a5905a6243d88a7c347c003b9c8789801"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function performs performs the kosaraju algorthm on the graph to find the strongly connected components.  <a href="../../d0/df2/classCXXGRAPH_1_1Graph.html#a5905a6243d88a7c347c003b9c8789801">More...</a><br /></td></tr>
<tr class="separator:a5905a6243d88a7c347c003b9c8789801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c6d8a66538ecec3c33c4ff0574cdb2d"><td class="memItemLeft" align="right" valign="top">virtual const std::vector&lt; <a class="el" href="../../d3/dd2/classCXXGRAPH_1_1Node.html">Node</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html#a7c6d8a66538ecec3c33c4ff0574cdb2d">graph_slicing</a> (const <a class="el" href="../../d3/dd2/classCXXGRAPH_1_1Node.html">Node</a>&lt; T &gt; &amp;start) const</td></tr>
<tr class="memdesc:a7c6d8a66538ecec3c33c4ff0574cdb2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function performs <a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html" title="Class that implement the Graph. ( This class is not Thread Safe )">Graph</a> Slicing based on connectivity.  <a href="../../d0/df2/classCXXGRAPH_1_1Graph.html#a7c6d8a66538ecec3c33c4ff0574cdb2d">More...</a><br /></td></tr>
<tr class="separator:a7c6d8a66538ecec3c33c4ff0574cdb2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a662a0e15cd997252639e7a257b830190"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="../../d5/d93/structCXXGRAPH_1_1DialResult__struct.html">DialResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html#a662a0e15cd997252639e7a257b830190">dial</a> (const <a class="el" href="../../d3/dd2/classCXXGRAPH_1_1Node.html">Node</a>&lt; T &gt; &amp;source, int maxWeight) const</td></tr>
<tr class="memdesc:a662a0e15cd997252639e7a257b830190"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function write the graph in an output file Note: No Thread Safe.  <a href="../../d0/df2/classCXXGRAPH_1_1Graph.html#a662a0e15cd997252639e7a257b830190">More...</a><br /></td></tr>
<tr class="separator:a662a0e15cd997252639e7a257b830190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47608dbab5286badf6098a54bb2fa364"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html#a47608dbab5286badf6098a54bb2fa364">fordFulkersonMaxFlow</a> (const <a class="el" href="../../d3/dd2/classCXXGRAPH_1_1Node.html">Node</a>&lt; T &gt; &amp;source, const <a class="el" href="../../d3/dd2/classCXXGRAPH_1_1Node.html">Node</a>&lt; T &gt; &amp;target) const</td></tr>
<tr class="memdesc:a47608dbab5286badf6098a54bb2fa364"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function runs the Ford-Fulkerson algorithm for some source node and target node in the graph and returns the maximum flow of the graph.  <a href="../../d0/df2/classCXXGRAPH_1_1Graph.html#a47608dbab5286badf6098a54bb2fa364">More...</a><br /></td></tr>
<tr class="separator:a47608dbab5286badf6098a54bb2fa364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a1ffeb9ef3b62b38c10bd84b44170a0"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html#a5a1ffeb9ef3b62b38c10bd84b44170a0">writeToFile</a> (InputOutputFormat format=InputOutputFormat::STANDARD_CSV, const std::string &amp;workingDir=&quot;.&quot;, const std::string &amp;OFileName=&quot;graph&quot;, bool compress=false, bool writeNodeFeat=false, bool writeEdgeWeight=false) const</td></tr>
<tr class="memdesc:a5a1ffeb9ef3b62b38c10bd84b44170a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function write the graph in an output file Note: No Thread Safe.  <a href="../../d0/df2/classCXXGRAPH_1_1Graph.html#a5a1ffeb9ef3b62b38c10bd84b44170a0">More...</a><br /></td></tr>
<tr class="separator:a5a1ffeb9ef3b62b38c10bd84b44170a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd5baeb88c2b588c14383155fff4ec3e"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html#abd5baeb88c2b588c14383155fff4ec3e">readFromFile</a> (InputOutputFormat format=InputOutputFormat::STANDARD_CSV, const std::string &amp;workingDir=&quot;.&quot;, const std::string &amp;OFileName=&quot;graph&quot;, bool compress=false, bool readNodeFeat=false, bool readEdgeWeight=false)</td></tr>
<tr class="memdesc:abd5baeb88c2b588c14383155fff4ec3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function read the graph from an input file Note: No Thread Safe.  <a href="../../d0/df2/classCXXGRAPH_1_1Graph.html#abd5baeb88c2b588c14383155fff4ec3e">More...</a><br /></td></tr>
<tr class="separator:abd5baeb88c2b588c14383155fff4ec3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70da23746ecfd20c8b5b226322813af2"><td class="memItemLeft" align="right" valign="top">virtual PartitionMap&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html#a70da23746ecfd20c8b5b226322813af2">partitionGraph</a> (PARTITIONING::PartitionAlgorithm algorithm, unsigned int numberOfPartitions, double param1=0.0, double param2=0.0, double param3=0.0, unsigned int numberOfthreads=std::thread::hardware_concurrency()) const</td></tr>
<tr class="memdesc:a70da23746ecfd20c8b5b226322813af2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function partition a graph in a set of partitions Note: No Thread Safe.  <a href="../../d0/df2/classCXXGRAPH_1_1Graph.html#a70da23746ecfd20c8b5b226322813af2">More...</a><br /></td></tr>
<tr class="separator:a70da23746ecfd20c8b5b226322813af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a8cf06edd83359e8fb9634e9036e0334b"><td class="memItemLeft" align="right" valign="top"><a id="a8cf06edd83359e8fb9634e9036e0334b"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html">Graph</a>&lt; T &gt; &amp;graph)</td></tr>
<tr class="separator:a8cf06edd83359e8fb9634e9036e0334b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35626ad6a1edaf1309a82bcdd9ab4ee1"><td class="memItemLeft" align="right" valign="top"><a id="a35626ad6a1edaf1309a82bcdd9ab4ee1"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const AdjacencyMatrix&lt; T &gt; &amp;adj)</td></tr>
<tr class="separator:a35626ad6a1edaf1309a82bcdd9ab4ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class CXXGRAPH::Graph&lt; T &gt;</h3>

<p>Class that implement the <a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html" title="Class that implement the Graph. ( This class is not Thread Safe )">Graph</a>. ( This class is not Thread Safe ) </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a95fc676b51609323126e1d6f2366c4bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95fc676b51609323126e1d6f2366c4bb">&#9670;&nbsp;</a></span>addEdge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html">CXXGRAPH::Graph</a>&lt; T &gt;::addEdge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/d2a/classCXXGRAPH_1_1Edge.html">Edge</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function add an <a class="el" href="../../d7/d2a/classCXXGRAPH_1_1Edge.html">Edge</a> to the <a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html" title="Class that implement the Graph. ( This class is not Thread Safe )">Graph</a> <a class="el" href="../../d7/d2a/classCXXGRAPH_1_1Edge.html">Edge</a> Set Note: No Thread Safe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edge</td><td>The <a class="el" href="../../d7/d2a/classCXXGRAPH_1_1Edge.html">Edge</a> to insert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae88da3d693fb461b53435d94e12e166c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae88da3d693fb461b53435d94e12e166c">&#9670;&nbsp;</a></span>bellmanford()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d4/df1/structCXXGRAPH_1_1BellmanFordResult__struct.html">BellmanFordResult</a> <a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html">CXXGRAPH::Graph</a>&lt; T &gt;::bellmanford </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/dd2/classCXXGRAPH_1_1Node.html">Node</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d3/dd2/classCXXGRAPH_1_1Node.html">Node</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function runs the bellman-ford algorithm for some source node and target node in the graph and returns the shortest distance of target from the source. It can also detect if a negative cycle exists in the graph. Note: No Thread Safe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>source vertex </td></tr>
    <tr><td class="paramname">target</td><td>target vertex</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>shortest distance if target is reachable from source else ERROR in case if target is not reachable from source. If there is no error then also returns if the graph contains a negative cycle. </dd></dl>

</div>
</div>
<a id="a8ff4c2379cae5b2426788e4bbcd174bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ff4c2379cae5b2426788e4bbcd174bc">&#9670;&nbsp;</a></span>boruvka()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d4/d63/structCXXGRAPH_1_1MstResult__struct.html">MstResult</a> <a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html">CXXGRAPH::Graph</a>&lt; T &gt;::boruvka</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function runs the boruvka algorithm and returns the minimum spanning tree &amp; cost if the graph is undirected. Note: No Thread Safe. </p>
<dl class="section return"><dt>Returns</dt><dd>struct of type MstResult with following fields success: true if algorithm completed successfully ELSE false mst: vector containing id of nodes in minimum spanning tree &amp; cost of MST mstCost: Cost of MST errorMessage: "" if no error ELSE report the encountered error </dd></dl>

</div>
</div>
<a id="ae94a68dc57331c26070c3aec035264ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae94a68dc57331c26070c3aec035264ef">&#9670;&nbsp;</a></span>breadth_first_search()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="../../d3/dd2/classCXXGRAPH_1_1Node.html">Node</a>&lt; T &gt; &gt; <a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html">CXXGRAPH::Graph</a>&lt; T &gt;::breadth_first_search </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/dd2/classCXXGRAPH_1_1Node.html">Node</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>start</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function performs the breadth first search algorithm over the graph Note: No Thread Safe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td><a class="el" href="../../d3/dd2/classCXXGRAPH_1_1Node.html">Node</a> from where traversing starts </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of <a class="el" href="../../d3/dd2/classCXXGRAPH_1_1Node.html">Node</a> indicating which <a class="el" href="../../d3/dd2/classCXXGRAPH_1_1Node.html">Node</a> were visited during the search. </dd></dl>

</div>
</div>
<a id="a54c736ce873d01a0ae290e8a2b448ca2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54c736ce873d01a0ae290e8a2b448ca2">&#9670;&nbsp;</a></span>containsCycle() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html">CXXGRAPH::Graph</a>&lt; T &gt;::containsCycle </td>
          <td>(</td>
          <td class="paramtype">const T_EdgeSet&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>edgeSet</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function checks if the given set of edges forms a cycle or not using union-find method. </p>
<dl class="section return"><dt>Returns</dt><dd>true if a cycle is detected, else false </dd></dl>

</div>
</div>
<a id="afa6c90c1c0e48c74fd486ef87b9626dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa6c90c1c0e48c74fd486ef87b9626dd">&#9670;&nbsp;</a></span>containsCycle() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html">CXXGRAPH::Graph</a>&lt; T &gt;::containsCycle </td>
          <td>(</td>
          <td class="paramtype">const T_EdgeSet&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>edgeSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_map&lt; unsigned long long, <a class="el" href="../../dc/daa/structCXXGRAPH_1_1Subset__struct.html">Subset</a> &gt; *&#160;</td>
          <td class="paramname"><em>subset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function checks if the given Subset forms a cycle or not using union-find method. </p>
<dl class="section return"><dt>Returns</dt><dd>true if a cycle is detected, else false </dd></dl>

</div>
</div>
<a id="a05d230bd6185b99b624227c4c82b7811"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05d230bd6185b99b624227c4c82b7811">&#9670;&nbsp;</a></span>depth_first_search()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="../../d3/dd2/classCXXGRAPH_1_1Node.html">Node</a>&lt; T &gt; &gt; <a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html">CXXGRAPH::Graph</a>&lt; T &gt;::depth_first_search </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/dd2/classCXXGRAPH_1_1Node.html">Node</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>start</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function performs the depth first search algorithm over the graph Note: No Thread Safe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td><a class="el" href="../../d3/dd2/classCXXGRAPH_1_1Node.html">Node</a> from where traversing starts </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of <a class="el" href="../../d3/dd2/classCXXGRAPH_1_1Node.html">Node</a> indicating which <a class="el" href="../../d3/dd2/classCXXGRAPH_1_1Node.html">Node</a> were visited during the search. </dd></dl>

</div>
</div>
<a id="a662a0e15cd997252639e7a257b830190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a662a0e15cd997252639e7a257b830190">&#9670;&nbsp;</a></span>dial()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d5/d93/structCXXGRAPH_1_1DialResult__struct.html">DialResult</a> <a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html">CXXGRAPH::Graph</a>&lt; T &gt;::dial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/dd2/classCXXGRAPH_1_1Node.html">Node</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxWeight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function write the graph in an output file Note: No Thread Safe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>The Output format of the file </td></tr>
    <tr><td class="paramname">workingDir</td><td>The path to the directory in which will be placed the output file </td></tr>
    <tr><td class="paramname">OFileName</td><td>The Output File Name ( ) </td></tr>
    <tr><td class="paramname">compress</td><td>Indicates if the output will be compressed </td></tr>
    <tr><td class="paramname">writeNodeFeat</td><td>Indicates if export also <a class="el" href="../../d3/dd2/classCXXGRAPH_1_1Node.html">Node</a> Features </td></tr>
    <tr><td class="paramname">writeEdgeWeight</td><td>Indicates if export also <a class="el" href="../../d7/d2a/classCXXGRAPH_1_1Edge.html">Edge</a> Weights </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if all OK, else return a negative value</dd></dl>
<p>Function runs the Dial algorithm (Optimized Dijkstra for small range weights) for some source node and target node in the graph and returns the shortest distance of target from the source. Note: No Thread Safe</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>source vertex </td></tr>
    <tr><td class="paramname">maxWeight</td><td>maximum weight of the edge</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>shortest distance for all nodes reachable from source else ERROR in case there is error in the computation. </dd></dl>

</div>
</div>
<a id="a8d655cd624cedf47ee366d8c0ab31921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d655cd624cedf47ee366d8c0ab31921">&#9670;&nbsp;</a></span>dijkstra()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../dd/d6c/structCXXGRAPH_1_1DijkstraResult__struct.html">DijkstraResult</a> <a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html">CXXGRAPH::Graph</a>&lt; T &gt;::dijkstra </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/dd2/classCXXGRAPH_1_1Node.html">Node</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d3/dd2/classCXXGRAPH_1_1Node.html">Node</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function runs the dijkstra algorithm for some source node and target node in the graph and returns the shortest distance of target from the source. Note: No Thread Safe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>source vertex </td></tr>
    <tr><td class="paramname">target</td><td>target vertex</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>shortest distance if target is reachable from source else ERROR in case if target is not reachable from source or there is error in the computation. </dd></dl>

</div>
</div>
<a id="a31b482ce494f93dcd7125b3aa4eb8f78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31b482ce494f93dcd7125b3aa4eb8f78">&#9670;&nbsp;</a></span>eulerianPath()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="../../d3/dd2/classCXXGRAPH_1_1Node.html">Node</a>&lt; T &gt; &gt; <a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html">CXXGRAPH::Graph</a>&lt; T &gt;::eulerianPath</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function finds the eulerian path of a directed graph using hierholzers algorithm. </p>
<dl class="section return"><dt>Returns</dt><dd>a vector containing nodes in eulerian path Note: No Thread Safe </dd></dl>

</div>
</div>
<a id="a00b6780a5167547fe05db00e01011223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00b6780a5167547fe05db00e01011223">&#9670;&nbsp;</a></span>floydWarshall()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../dc/da9/structCXXGRAPH_1_1FWResult__struct.html">FWResult</a> <a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html">CXXGRAPH::Graph</a>&lt; T &gt;::floydWarshall</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function runs the floyd-warshall algorithm and returns the shortest distance of all pair of nodes. It can also detect if a negative cycle exists in the graph. Note: No Thread Safe. </p>
<dl class="section return"><dt>Returns</dt><dd>a map whose keys are node ids and values are the shortest distance. If there is no error then also returns if the graph contains a negative cycle. </dd></dl>

</div>
</div>
<a id="a47608dbab5286badf6098a54bb2fa364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47608dbab5286badf6098a54bb2fa364">&#9670;&nbsp;</a></span>fordFulkersonMaxFlow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html">CXXGRAPH::Graph</a>&lt; T &gt;::fordFulkersonMaxFlow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/dd2/classCXXGRAPH_1_1Node.html">Node</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d3/dd2/classCXXGRAPH_1_1Node.html">Node</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function runs the Ford-Fulkerson algorithm for some source node and target node in the graph and returns the maximum flow of the graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>source vertex </td></tr>
    <tr><td class="paramname">target</td><td>target vertex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double Max-Flow value or -1 in case of error </dd></dl>

</div>
</div>
<a id="a5ebab9011fe6155743eaa989c2bf7860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ebab9011fe6155743eaa989c2bf7860">&#9670;&nbsp;</a></span>getEdge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::optional&lt; const <a class="el" href="../../d7/d2a/classCXXGRAPH_1_1Edge.html">Edge</a>&lt; T &gt; * &gt; <a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html">CXXGRAPH::Graph</a>&lt; T &gt;::getEdge </td>
          <td>(</td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>edgeId</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that return an <a class="el" href="../../d7/d2a/classCXXGRAPH_1_1Edge.html">Edge</a> with specific ID if Exist in the <a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html" title="Class that implement the Graph. ( This class is not Thread Safe )">Graph</a> Note: No Thread Safe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edgeId</td><td>The <a class="el" href="../../d7/d2a/classCXXGRAPH_1_1Edge.html">Edge</a> Id to return </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="../../d7/d2a/classCXXGRAPH_1_1Edge.html">Edge</a> if exist </dd></dl>

</div>
</div>
<a id="a8412ba5fbb3bd12ce9c872bd9bbd9824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8412ba5fbb3bd12ce9c872bd9bbd9824">&#9670;&nbsp;</a></span>getEdgeSet()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T_EdgeSet&lt; T &gt; &amp; <a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html">CXXGRAPH::Graph</a>&lt; T &gt;::getEdgeSet</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that return the <a class="el" href="../../d7/d2a/classCXXGRAPH_1_1Edge.html">Edge</a> set of the <a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html" title="Class that implement the Graph. ( This class is not Thread Safe )">Graph</a> Note: No Thread Safe. </p>
<dl class="section return"><dt>Returns</dt><dd>a list of Edges of the graph </dd></dl>

</div>
</div>
<a id="af0544d74b956980e05e2a57a5dc2d2d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0544d74b956980e05e2a57a5dc2d2d6">&#9670;&nbsp;</a></span>getNodeSet()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::set&lt; const <a class="el" href="../../d3/dd2/classCXXGRAPH_1_1Node.html">Node</a>&lt; T &gt; * &gt; <a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html">CXXGRAPH::Graph</a>&lt; T &gt;::getNodeSet</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that return the <a class="el" href="../../d3/dd2/classCXXGRAPH_1_1Node.html">Node</a> Set of the <a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html" title="Class that implement the Graph. ( This class is not Thread Safe )">Graph</a> Note: No Thread Safe. </p>
<dl class="section return"><dt>Returns</dt><dd>a list of Nodes of the graph </dd></dl>

</div>
</div>
<a id="a7c6d8a66538ecec3c33c4ff0574cdb2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c6d8a66538ecec3c33c4ff0574cdb2d">&#9670;&nbsp;</a></span>graph_slicing()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="../../d3/dd2/classCXXGRAPH_1_1Node.html">Node</a>&lt; T &gt; &gt; <a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html">CXXGRAPH::Graph</a>&lt; T &gt;::graph_slicing </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/dd2/classCXXGRAPH_1_1Node.html">Node</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>start</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function performs <a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html" title="Class that implement the Graph. ( This class is not Thread Safe )">Graph</a> Slicing based on connectivity. </p>
<p>Mathematical definition of the problem:</p>
<p>Let G be the set of nodes in a graph and n be a given node in that set. Let C be the non-strict subset of G containing both n and all nodes reachable from n, and let C' be its complement. There's a third set M, which is the non-strict subset of C containing all nodes that are reachable from any node in C'. The problem consists of finding all nodes that belong to C but not to M.</p>
<p>Note: No Thread Safe </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td><a class="el" href="../../d3/dd2/classCXXGRAPH_1_1Node.html">Node</a> from where traversing starts </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of nodes that belong to C but not to M. </dd></dl>

</div>
</div>
<a id="a1c7fc1183438f6f699179a4b02d39b68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c7fc1183438f6f699179a4b02d39b68">&#9670;&nbsp;</a></span>isConnectedGraph()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html">CXXGRAPH::Graph</a>&lt; T &gt;::isConnectedGraph</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function checks if the graph is connected or not Applicable for Undirected <a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html" title="Class that implement the Graph. ( This class is not Thread Safe )">Graph</a>, for Directed <a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html" title="Class that implement the Graph. ( This class is not Thread Safe )">Graph</a> use the <a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html#a2dd3a83617afbd6a27d9f835f0ac7996" title="This function checks if the graph is strongly connected or not Applicable for Directed Graph,...">isStronglyConnectedGraph()</a> function. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the graph is connected </dd>
<dd>
false otherwise </dd></dl>

</div>
</div>
<a id="a4f76bb7230c1654dd6b1ec24d0291875"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f76bb7230c1654dd6b1ec24d0291875">&#9670;&nbsp;</a></span>isCyclicDirectedGraphBFS()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html">CXXGRAPH::Graph</a>&lt; T &gt;::isCyclicDirectedGraphBFS</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function uses BFS to check for cycle in the graph. Pay Attention, this function work only with directed <a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html" title="Class that implement the Graph. ( This class is not Thread Safe )">Graph</a> Note: No Thread Safe. </p>
<dl class="section return"><dt>Returns</dt><dd>true if a cycle is detected, else false. ( false is returned also if the graph in indirected) </dd></dl>

</div>
</div>
<a id="a91a818601c0df0e5abfbaf4da5918afa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91a818601c0df0e5abfbaf4da5918afa">&#9670;&nbsp;</a></span>isCyclicDirectedGraphDFS()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html">CXXGRAPH::Graph</a>&lt; T &gt;::isCyclicDirectedGraphDFS</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function uses DFS to check for cycle in the graph. Pay Attention, this function work only with directed <a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html" title="Class that implement the Graph. ( This class is not Thread Safe )">Graph</a> Note: No Thread Safe. </p>
<dl class="section return"><dt>Returns</dt><dd>true if a cycle is detected, else false. ( false is returned also if the graph in indirected) </dd></dl>

</div>
</div>
<a id="a5c7ddb5c91f3ab7456c8203a740f52c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c7ddb5c91f3ab7456c8203a740f52c9">&#9670;&nbsp;</a></span>isDirectedGraph()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html">CXXGRAPH::Graph</a>&lt; T &gt;::isDirectedGraph</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function checks if a graph is directed Note: No Thread Safe. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the graph is directed, else false. </dd></dl>

</div>
</div>
<a id="a2dd3a83617afbd6a27d9f835f0ac7996"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dd3a83617afbd6a27d9f835f0ac7996">&#9670;&nbsp;</a></span>isStronglyConnectedGraph()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html">CXXGRAPH::Graph</a>&lt; T &gt;::isStronglyConnectedGraph</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function checks if the graph is strongly connected or not Applicable for Directed <a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html" title="Class that implement the Graph. ( This class is not Thread Safe )">Graph</a>, for Undirected <a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html" title="Class that implement the Graph. ( This class is not Thread Safe )">Graph</a> use the <a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html#a1c7fc1183438f6f699179a4b02d39b68" title="This function checks if the graph is connected or not Applicable for Undirected Graph,...">isConnectedGraph()</a> function. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the graph is connected </dd>
<dd>
false otherwise </dd></dl>

</div>
</div>
<a id="a13abdb1d53937f7349cd72f527125edf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13abdb1d53937f7349cd72f527125edf">&#9670;&nbsp;</a></span>isUndirectedGraph()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html">CXXGRAPH::Graph</a>&lt; T &gt;::isUndirectedGraph</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function checks if a graph is undirected Note: No Thread Safe. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the graph is undirected, else false. </dd></dl>

</div>
</div>
<a id="a5905a6243d88a7c347c003b9c8789801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5905a6243d88a7c347c003b9c8789801">&#9670;&nbsp;</a></span>kosaraju()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; <a class="el" href="../../d3/dd2/classCXXGRAPH_1_1Node.html">Node</a>&lt; T &gt; &gt; &gt; <a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html">CXXGRAPH::Graph</a>&lt; T &gt;::kosaraju</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function performs performs the kosaraju algorthm on the graph to find the strongly connected components. </p>
<p>Mathematical definition of the problem: A strongly connected component (SCC) of a directed graph is a maximal strongly connected subgraph.</p>
<p>Note: No Thread Safe </p><dl class="section return"><dt>Returns</dt><dd>a vector of vector of strongly connected components. </dd></dl>

</div>
</div>
<a id="acd02bf70592b8f706d441e82bbe6ddc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd02bf70592b8f706d441e82bbe6ddc9">&#9670;&nbsp;</a></span>kruskal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d4/d63/structCXXGRAPH_1_1MstResult__struct.html">MstResult</a> <a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html">CXXGRAPH::Graph</a>&lt; T &gt;::kruskal</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function runs the kruskal algorithm and returns the minimum spanning tree if the graph is undirected. Note: No Thread Safe. </p>
<dl class="section return"><dt>Returns</dt><dd>struct of type MstResult with following fields success: true if algorithm completed successfully ELSE false mst: vector containing id of nodes in minimum spanning tree &amp; cost of MST mstCost: Cost of MST errorMessage: "" if no error ELSE report the encountered error </dd></dl>

</div>
</div>
<a id="a70da23746ecfd20c8b5b226322813af2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70da23746ecfd20c8b5b226322813af2">&#9670;&nbsp;</a></span>partitionGraph()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PartitionMap&lt; T &gt; <a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html">CXXGRAPH::Graph</a>&lt; T &gt;::partitionGraph </td>
          <td>(</td>
          <td class="paramtype">PARTITIONING::PartitionAlgorithm&#160;</td>
          <td class="paramname"><em>algorithm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>numberOfPartitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>param1</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>param2</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>param3</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>numberOfthreads</em> = <code>std::thread::hardware_concurrency()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function partition a graph in a set of partitions Note: No Thread Safe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">algorithm</td><td>The partition algorithm </td></tr>
    <tr><td class="paramname">numberOfPartition</td><td>The number of partitions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The partiton Map of the partitioned graph </dd></dl>

</div>
</div>
<a id="a1dd966cbf26d661a017e36d568fa3223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dd966cbf26d661a017e36d568fa3223">&#9670;&nbsp;</a></span>prim()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d4/d63/structCXXGRAPH_1_1MstResult__struct.html">MstResult</a> <a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html">CXXGRAPH::Graph</a>&lt; T &gt;::prim</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function runs the prim algorithm and returns the minimum spanning tree if the graph is undirected. Note: No Thread Safe. </p>
<dl class="section return"><dt>Returns</dt><dd>a vector containing id of nodes in minimum spanning tree &amp; cost of MST </dd></dl>

</div>
</div>
<a id="abd5baeb88c2b588c14383155fff4ec3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd5baeb88c2b588c14383155fff4ec3e">&#9670;&nbsp;</a></span>readFromFile()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html">CXXGRAPH::Graph</a>&lt; T &gt;::readFromFile </td>
          <td>(</td>
          <td class="paramtype">InputOutputFormat&#160;</td>
          <td class="paramname"><em>format</em> = <code>InputOutputFormat::STANDARD_CSV</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>workingDir</em> = <code>&quot;.&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>OFileName</em> = <code>&quot;graph&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>compress</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>readNodeFeat</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>readEdgeWeight</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function read the graph from an input file Note: No Thread Safe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>The Input format of the file </td></tr>
    <tr><td class="paramname">workingDir</td><td>The path to the directory in which is placed the Input file </td></tr>
    <tr><td class="paramname">OFileName</td><td>The Input File Name ( ) </td></tr>
    <tr><td class="paramname">compress</td><td>Indicates if the Input is compressed </td></tr>
    <tr><td class="paramname">readNodeFeat</td><td>Indicates if import also <a class="el" href="../../d3/dd2/classCXXGRAPH_1_1Node.html">Node</a> Features </td></tr>
    <tr><td class="paramname">readEdgeWeight</td><td>Indicates if import also <a class="el" href="../../d7/d2a/classCXXGRAPH_1_1Edge.html">Edge</a> Weights </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if all OK, else return a negative value </dd></dl>

</div>
</div>
<a id="ac1b14104add48bad5524e31b47411d36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1b14104add48bad5524e31b47411d36">&#9670;&nbsp;</a></span>removeEdge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html">CXXGRAPH::Graph</a>&lt; T &gt;::removeEdge </td>
          <td>(</td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>edgeId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function remove an <a class="el" href="../../d7/d2a/classCXXGRAPH_1_1Edge.html">Edge</a> from the <a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html" title="Class that implement the Graph. ( This class is not Thread Safe )">Graph</a> <a class="el" href="../../d7/d2a/classCXXGRAPH_1_1Edge.html">Edge</a> Set Note: No Thread Safe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edgeId</td><td>The <a class="el" href="../../d7/d2a/classCXXGRAPH_1_1Edge.html">Edge</a> Id to remove </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7f4b22c1c3e93bd51600141d9517e36a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f4b22c1c3e93bd51600141d9517e36a">&#9670;&nbsp;</a></span>setEdgeSet()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html">CXXGRAPH::Graph</a>&lt; T &gt;::setEdgeSet </td>
          <td>(</td>
          <td class="paramtype">T_EdgeSet&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>edgeSet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function set the <a class="el" href="../../d7/d2a/classCXXGRAPH_1_1Edge.html">Edge</a> Set of the <a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html" title="Class that implement the Graph. ( This class is not Thread Safe )">Graph</a> Note: No Thread Safe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edgeSet</td><td>The <a class="el" href="../../d7/d2a/classCXXGRAPH_1_1Edge.html">Edge</a> Set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0cc15d4668136f6be44bf18a2e28cc6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cc15d4668136f6be44bf18a2e28cc6b">&#9670;&nbsp;</a></span>setFind()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long long <a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html">CXXGRAPH::Graph</a>&lt; T &gt;::setFind </td>
          <td>(</td>
          <td class="paramtype">std::unordered_map&lt; unsigned long long, <a class="el" href="../../dc/daa/structCXXGRAPH_1_1Subset__struct.html">Subset</a> &gt; *&#160;</td>
          <td class="paramname"><em>subsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned long long&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function finds the subset of given a nodeId Subset is stored in a map where keys are the hash-id of the node &amp; values is the subset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subset</td><td>query subset, we want to find target in this subset </td></tr>
    <tr><td class="paramname">elem</td><td>elem that we wish to find in the subset</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>parent node of elem Note: No Thread Safe </dd></dl>

</div>
</div>
<a id="a60a3f55bd4b195d7225b77b3ae8c9065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60a3f55bd4b195d7225b77b3ae8c9065">&#9670;&nbsp;</a></span>setUnion()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html">CXXGRAPH::Graph</a>&lt; T &gt;::setUnion </td>
          <td>(</td>
          <td class="paramtype">std::unordered_map&lt; unsigned long long, <a class="el" href="../../dc/daa/structCXXGRAPH_1_1Subset__struct.html">Subset</a> &gt; *&#160;</td>
          <td class="paramname"><em>subsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned long long&#160;</td>
          <td class="paramname"><em>set1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned long long&#160;</td>
          <td class="paramname"><em>elem2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function modifies the original subset array such that it the union of two sets a and b. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subset</td><td>original subset is modified to obtain union of a &amp; b </td></tr>
    <tr><td class="paramname">a</td><td>parent id of set1 </td></tr>
    <tr><td class="paramname">b</td><td>parent id of set2 NOTE: Original subset is no longer available after union. Note: No Thread Safe </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5a1ffeb9ef3b62b38c10bd84b44170a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a1ffeb9ef3b62b38c10bd84b44170a0">&#9670;&nbsp;</a></span>writeToFile()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="../../d0/df2/classCXXGRAPH_1_1Graph.html">CXXGRAPH::Graph</a>&lt; T &gt;::writeToFile </td>
          <td>(</td>
          <td class="paramtype">InputOutputFormat&#160;</td>
          <td class="paramname"><em>format</em> = <code>InputOutputFormat::STANDARD_CSV</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>workingDir</em> = <code>&quot;.&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>OFileName</em> = <code>&quot;graph&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>compress</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>writeNodeFeat</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>writeEdgeWeight</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function write the graph in an output file Note: No Thread Safe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>The Output format of the file </td></tr>
    <tr><td class="paramname">workingDir</td><td>The path to the directory in which is placed the Output file </td></tr>
    <tr><td class="paramname">OFileName</td><td>The Output File Name ( ) </td></tr>
    <tr><td class="paramname">compress</td><td>Indicates if the Output will be compressed ( Pay Attention if compress flag is true, not compressed files will be deleted [ #48 ] ) </td></tr>
    <tr><td class="paramname">writeNodeFeat</td><td>Indicates if export also <a class="el" href="../../d3/dd2/classCXXGRAPH_1_1Node.html">Node</a> Features </td></tr>
    <tr><td class="paramname">writeEdgeWeight</td><td>Indicates if export also <a class="el" href="../../d7/d2a/classCXXGRAPH_1_1Edge.html">Edge</a> Weights </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if all OK, else return a negative value </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/github/workspace/include/Graph/<a class="el" href="../../d9/d69/Graph_8hpp_source.html">Graph.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
