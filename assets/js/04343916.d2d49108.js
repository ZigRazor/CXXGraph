"use strict";(self.webpackChunkcxx_graph_docs=self.webpackChunkcxx_graph_docs||[]).push([[479],{8741:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>h});var n=i(4848),a=i(8453);const o={id:"partition-algorithm",title:"Partition Algorithms Explanation",tags:["algorithm","partition-algorithm","components","graphing-components","graphing"]},r=void 0,s={id:"component-explanation/partition-algorithm",title:"Partition Algorithms Explanation",description:"Vertex-Cut",source:"@site/docs/component-explanation/partition-algorithm.md",sourceDirName:"component-explanation",slug:"/component-explanation/partition-algorithm",permalink:"/ / /component-explanation/partition-algorithm",draft:!1,unlisted:!1,editUrl:"https://github.com/ZigRazor/CXXGraph/docs/component-explanation/partition-algorithm.md",tags:[{label:"algorithm",permalink:"/ / /tags/algorithm"},{label:"partition-algorithm",permalink:"/ / /tags/partition-algorithm"},{label:"components",permalink:"/ / /tags/components"},{label:"graphing-components",permalink:"/ / /tags/graphing-components"},{label:"graphing",permalink:"/ / /tags/graphing"}],version:"current",frontMatter:{id:"partition-algorithm",title:"Partition Algorithms Explanation",tags:["algorithm","partition-algorithm","components","graphing-components","graphing"]},sidebar:"docSidebar",previous:{title:"Network Dynamics",permalink:"/ / /component-explanation/network-dynamics"},next:{title:"Algorithms Explanation",permalink:"/ / /component-explanation/regular-algorithm"}},l={},h=[{value:"Vertex-Cut",id:"vertex-cut",level:3},{value:"Edge Balanced Vertex-Cut",id:"edge-balanced-vertex-cut",level:3},{value:"Greedy Vertex-Cut",id:"greedy-vertex-cut",level:3},{value:"HDRF",id:"hdrf",level:3},{value:"EBV",id:"ebv",level:3}];function c(e){const t={a:"a",code:"code",h3:"h3",li:"li",ol:"ol",p:"p",...(0,a.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h3,{id:"vertex-cut",children:"Vertex-Cut"}),"\n",(0,n.jsx)(t.p,{children:"A vertex-cut partitioning divides edges of a graph into equal size partitions. The vertices that hold the endpoints of an edge are also placed in the same partition as the edge itself. However, the vertices are not unique across partitions and might have to be replicated (cut), due to the distribution of their edge across different partitions."}),"\n",(0,n.jsx)(t.p,{children:"Replication factor quantifies how many vertices are replicated over computers compared with the the number of vertices of the original input graph."}),"\n",(0,n.jsx)(t.h3,{id:"edge-balanced-vertex-cut",children:"Edge Balanced Vertex-Cut"}),"\n",(0,n.jsx)(t.p,{children:"This Algorithm is a simple vertex-cut in Round-Robin fashion. It takes the original graph edges and assign them to the partitions, dividing it in equal(or similar) size. This algorithm does not take care of optimization in vertex replication ( Replication Factor) but only balance the edge in the partitions."}),"\n",(0,n.jsx)(t.h3,{id:"greedy-vertex-cut",children:"Greedy Vertex-Cut"}),"\n",(0,n.jsx)(t.p,{children:"Greedy partitioning algorithms uses the entire history of the edge assignments to make the next decision. The algorithm stores the set of partitions A(v) to which each already observed vertex v has been assigned and the current partition sizes. When processing edge e \u2208 E connecting vertices vi, vj \u2208 V , the greedy algorithm follows this simple set of rules:"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsx)(t.li,{children:"If neither vi nor vj have been assigned to a partition, then e is placed in the partition with the smallest size in P."}),"\n",(0,n.jsx)(t.li,{children:"If only one of the two vertices has been already assigned (without loss of generality assume that vi is the assigned vertex) then e is placed in the partition with the smallest size in A(vi)."}),"\n",(0,n.jsx)(t.li,{children:"If A(vi) \u2229 A(vj ) 6= \u2205, then edge e is placed in the partition with the smallest size in A(vi) \u2229 A(vj)."}),"\n",(0,n.jsx)(t.li,{children:"If A(vi) != \u2205, A(vj ) != \u2205 and A(vi)\u2229A(vj ) = \u2205, then e is placed in the partition with the smallest size in A(vi)\u222aA(vj) and a new vertex replica is created accordingly."}),"\n"]}),"\n",(0,n.jsx)(t.h3,{id:"hdrf",children:"HDRF"}),"\n",(0,n.jsxs)(t.p,{children:["High Degree (are) Replicated First(HDRF) Algorithm is a greedy vertex-cut algorithm as described by this ",(0,n.jsx)(t.a,{href:"https://www.fabiopetroni.com/Download/petroni2015HDRF.pdf",children:"paper"}),". This Algorithm try to optimize Replication Factor by using the history of the edge assignements amd the incremental vertex degree. With a function that take in consideration this two factors calculate the best partition to assign the analyzed edge. The replica created are based on the degree of the verteices, and the vertices replicated are probably a so called \u201cHub-Node\u201d, which are the vertices with higher degree."]}),"\n",(0,n.jsx)(t.h3,{id:"ebv",children:"EBV"}),"\n",(0,n.jsx)(t.p,{children:"Efficient and Balanced Vertex-cut(EBV) is an offline vertex-cut algorithm as described by this paper. This algorithm try to balance the partitions with respect to the number of edges and vertices of each partitions and the Replication Factor. It apply a formula to evaluate the partition in which assigns the edge that take into consideration also the total number of edges and vertices of the graph. The evaluation formula is the following:"}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.code,{children:"Eva(u,v)(i) =I(u \u2208 keep[i]) + I(v \u2208 keep[i]) +\u03b1 * \\frac{ecount[i]}{(|E|/p)} + \u03b2 * \\frac{vcount[i]}{(|V|/p)}"}),"\nThe lowest value is taken as partition Id."]})]})}function d(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}},8453:(e,t,i)=>{i.d(t,{R:()=>r,x:()=>s});var n=i(6540);const a={},o=n.createContext(a);function r(e){const t=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),n.createElement(o.Provider,{value:t},e.children)}}}]);